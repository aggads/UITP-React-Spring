import { useReducer } from 'react';

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      _defineProperty(target, key, source[key]);
    });
  }

  return target;
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

function stateReducer(state, newState) {
  return _objectSpread({}, state, newState);
}

var CHECKBOX = 'checkbox';
var COLOR = 'color';
var DATE = 'date';
var EMAIL = 'email';
var MONTH = 'month';
var NUMBER = 'number';
var PASSWORD = 'password';
var RADIO = 'radio';
var RANGE = 'range';
var SEARCH = 'search';
var SELECT = 'select';
var TEL = 'tel';
var TEXT = 'text';
var TEXTAREA = 'textarea';
var TIME = 'time';
var URL = 'url';
var WEEK = 'week';
var TYPES = [CHECKBOX, COLOR, DATE, EMAIL, MONTH, NUMBER, PASSWORD, RADIO, RANGE, SEARCH, SELECT, TEL, TEXT, TEXTAREA, TIME, URL, WEEK];

function useFormState(initialState) {
  var _useReducer = useReducer(stateReducer, initialState || {}),
      _useReducer2 = _slicedToArray(_useReducer, 2),
      state = _useReducer2[0],
      setState = _useReducer2[1];

  var _useReducer3 = useReducer(stateReducer, {}),
      _useReducer4 = _slicedToArray(_useReducer3, 2),
      touched = _useReducer4[0],
      setTouchedState = _useReducer4[1];

  var _useReducer5 = useReducer(stateReducer, {}),
      _useReducer6 = _slicedToArray(_useReducer5, 2),
      validity = _useReducer6[0],
      setValidityState = _useReducer6[1];

  var createPropsGetter = function createPropsGetter(type) {
    return function (name, ownValue) {
      var hasOwnValue = !!ownValue;
      var hasValueInState = state[name] !== undefined;
      var isCheckbox = type === CHECKBOX;
      var isRadio = type === RADIO;

      function setInitialValue() {
        var value = '';

        if (isCheckbox) {
          /**
           * If a checkbox has a user-defined value, its value the form state
           * value will be an array. Otherwise it will be considered a toggle.
           */
          value = hasOwnValue ? [] : false;
        }

        setState(_defineProperty({}, name, value));
      }

      function getNextCheckboxValue(e) {
        var _e$target = e.target,
            value = _e$target.value,
            checked = _e$target.checked;

        if (!hasOwnValue) {
          return checked;
        }

        var checkedValues = new Set(state[name]);

        if (checked) {
          checkedValues.add(value);
        } else {
          checkedValues.delete(value);
        }

        return Array.from(checkedValues);
      }

      var inputProps = {
        name: name,

        get type() {
          if (type !== SELECT && type !== TEXTAREA) return type;
        },

        get checked() {
          if (isRadio) {
            return state[name] === ownValue;
          }

          if (isCheckbox) {
            if (!hasOwnValue) {
              return state[name] || false;
            }
            /**
             * @todo Handle the case where two checkbox inputs share the same
             * name, but one has a value, the other doesn't (throws currently).
             * <input {...input.checkbox('option1')} />
             * <input {...input.checkbox('option1', 'value_of_option1')} />
             */


            return hasValueInState ? state[name].includes(ownValue) : false;
          }
        },

        get value() {
          // auto populating initial state values on first render
          if (!hasValueInState) {
            setInitialValue();
          }
          /**
           * Since checkbox and radio inputs have their own user-defined values,
           * and since checkbox inputs can be either an array or a boolean,
           * returning the value of input from the current form state is illogical
           */


          if (isCheckbox || isRadio) {
            return ownValue;
          }

          return hasValueInState ? state[name] : '';
        },

        onChange: function onChange(e) {
          var value = e.target.value;

          if (isCheckbox) {
            value = getNextCheckboxValue(e);
          }

          setState(_defineProperty({}, name, value));
        },
        onBlur: function onBlur(e) {
          setTouchedState(_defineProperty({}, name, true));
          setValidityState(_defineProperty({}, name, e.target.validity.valid));
        }
      };
      return inputProps;
    };
  };

  var inputPropsCreators = TYPES.reduce(function (methods, type) {
    return _objectSpread({}, methods, _defineProperty({}, type, createPropsGetter(type)));
  }, {});
  return [{
    values: state,
    validity: validity,
    touched: touched
  }, inputPropsCreators];
}

/* eslint import/prefer-default-export: off */

export { useFormState };
